{"version":3,"names":[],"mappings":"","sources":["search.js"],"sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\nvar Config, Elastic, Filter, React, Search, Table;\n\nReact = window.React;\n\nConfig = require('./config');\n\nElastic = require('./elastic');\n\nFilter = require('./components/filter');\n\nSearch = require('./components/search');\n\nTable = require('./components/table');\n\nElastic.search();\n\nReact.render(React.createElement(Filter, null), document.getElementById('filter'));\n\nReact.render(React.createElement(Search, null), document.getElementById('search'));\n\nReact.render(React.createElement(Table, {\n  \"cols\": Config.fields\n}), document.getElementById('table'));\n\n\n\n},{\"./components/filter\":2,\"./components/search\":3,\"./components/table\":4,\"./config\":5,\"./elastic\":6}],2:[function(require,module,exports){\nvar Facet, Facets, React, State, Term, classNames;\n\nReact = window.React;\n\nclassNames = require('classnames');\n\nState = require('../state');\n\nTerm = React.createClass({\n  render: function() {\n    return React.createElement(\"li\", {\n      \"onClick\": this.handleClick,\n      \"className\": classNames({\n        selected: this.props.item.checked\n      })\n    }, React.createElement(\"div\", {\n      \"className\": \"checkbox\"\n    }), React.createElement(\"label\", null, _.capitalize(this.props.item.name)));\n  },\n  handleClick: function(e) {\n    return this.props.cursor.set('checked', !this.props.cursor.get('checked'));\n  }\n});\n\nFacet = React.createClass({\n  render: function() {\n    var i, item;\n    return React.createElement(\"div\", {\n      \"className\": \"dropdown\"\n    }, React.createElement(\"div\", {\n      \"className\": \"dropdown-container\"\n    }, React.createElement(\"div\", {\n      \"className\": \"dropdown-button\"\n    }, \"Accepted status\"), React.createElement(\"ul\", {\n      \"className\": \"dropdown-menu checkbox\"\n    }, (function() {\n      var j, len, ref, results;\n      ref = this.props.facet.items;\n      results = [];\n      for (i = j = 0, len = ref.length; j < len; i = ++j) {\n        item = ref[i];\n        results.push(React.createElement(Term, {\n          \"key\": i,\n          \"item\": item,\n          \"cursor\": this.props.cursor.select('items').select(i)\n        }));\n      }\n      return results;\n    }).call(this))));\n  }\n});\n\nFacets = React.createClass({\n  mixins: [State.mixin],\n  cursors: {\n    facets: ['filter', 'facets']\n  },\n  render: function() {\n    var facet, i;\n    return React.createElement(\"div\", {\n      \"className\": \"filter-group\"\n    }, (function() {\n      var j, len, ref, results;\n      ref = this.state.cursors.facets;\n      results = [];\n      for (i = j = 0, len = ref.length; j < len; i = ++j) {\n        facet = ref[i];\n        results.push(React.createElement(Facet, {\n          \"key\": i,\n          \"facet\": facet,\n          \"cursor\": this.cursors.facets.select(i)\n        }));\n      }\n      return results;\n    }).call(this));\n  }\n});\n\nmodule.exports = Facets;\n\n\n\n},{\"../state\":7,\"classnames\":20}],3:[function(require,module,exports){\nvar React, Search, State;\n\nReact = window.React;\n\nState = require('../state');\n\nSearch = React.createClass({\n  mixins: [State.mixin],\n  cursors: {\n    query: ['filter', 'query']\n  },\n  getInitialState: function() {\n    return {\n      query: ''\n    };\n  },\n  render: function() {\n    return React.createElement(\"input\", {\n      \"type\": \"text\",\n      \"placeholder\": \"Search\",\n      \"value\": this.state.query,\n      \"onChange\": this.handleChange\n    });\n  },\n  handleChange: function(e) {\n    this.setState({\n      query: e.target.value\n    });\n    return this.cursors.query.edit(e.target.value);\n  }\n});\n\nmodule.exports = Search;\n\n\n\n},{\"../state\":7}],4:[function(require,module,exports){\nvar React, State, Table, Tbody, Thead;\n\nReact = window.React;\n\nState = require('../state');\n\nTable = React.createClass({\n  mixins: [State.mixin],\n  cursors: {\n    celllines: ['celllines']\n  },\n  render: function() {\n    return React.createElement(\"table\", {\n      \"className\": \"listing\"\n    }, React.createElement(Thead, {\n      \"cols\": this.props.cols\n    }), React.createElement(Tbody, {\n      \"cols\": this.props.cols,\n      \"data\": this.state.cursors.celllines\n    }));\n  }\n});\n\nThead = React.createClass({\n  render: function() {\n    var col, i;\n    return React.createElement(\"thead\", null, React.createElement(\"tr\", null, (function() {\n      var j, len, ref, results;\n      ref = this.props.cols;\n      results = [];\n      for (i = j = 0, len = ref.length; j < len; i = ++j) {\n        col = ref[i];\n        results.push(React.createElement(\"th\", {\n          \"key\": i\n        }, col.label));\n      }\n      return results;\n    }).call(this)));\n  }\n});\n\nTbody = React.createClass({\n  render: function() {\n    var col, i, row;\n    if (!this.props.data) {\n      return '';\n    }\n    return React.createElement(\"tbody\", null, (function() {\n      var j, len, ref, results;\n      ref = this.props.data;\n      results = [];\n      for (j = 0, len = ref.length; j < len; j++) {\n        row = ref[j];\n        results.push(React.createElement(\"tr\", {\n          \"key\": row._id\n        }, (function() {\n          var k, len1, ref1, results1;\n          ref1 = this.props.cols;\n          results1 = [];\n          for (i = k = 0, len1 = ref1.length; k < len1; i = ++k) {\n            col = ref1[i];\n            results1.push(React.createElement(\"td\", {\n              \"key\": i\n            }, row._source[col.name]));\n          }\n          return results1;\n        }).call(this)));\n      }\n      return results;\n    }).call(this));\n  }\n});\n\nmodule.exports = Table;\n\n\n\n},{\"../state\":7}],5:[function(require,module,exports){\nvar config;\n\nconfig = {\n  fields: [\n    {\n      name: 'biosamplesid',\n      label: 'Biosamples ID'\n    }, {\n      name: 'celllinename',\n      label: 'Cell line Name'\n    }, {\n      name: 'celllineprimarydisease',\n      label: 'Disease'\n    }, {\n      name: 'celllineaccepted',\n      label: 'Accepted'\n    }\n  ],\n  query_fields: ['biosamplesid', 'celllinename', 'celllineprimarydisease']\n};\n\nmodule.exports = config;\n\n\n\n},{}],6:[function(require,module,exports){\nvar Elasticsearch, State, _, buildFacetFilter, buildFacetFilters, buildQuery, buildQueryFilter, elastic, search;\n\n_ = window._;\n\nElasticsearch = window.elasticsearch;\n\nState = require('./state');\n\nelastic = Elasticsearch.Client({\n  hosts: 'localhost:9200'\n});\n\nbuildFacetFilter = function(facet) {\n  var i, item, len, ref, results;\n  ref = facet.items;\n  results = [];\n  for (i = 0, len = ref.length; i < len; i++) {\n    item = ref[i];\n    if (item.checked) {\n      results.push(item.name);\n    }\n  }\n  return results;\n};\n\nbuildFacetFilters = function() {\n  var facet, filters;\n  filters = _.object((function() {\n    var i, len, ref, results;\n    ref = State.select('filter', 'facets').get();\n    results = [];\n    for (i = 0, len = ref.length; i < len; i++) {\n      facet = ref[i];\n      if (buildFacetFilter(facet).length > 0) {\n        results.push([facet.name, buildFacetFilter(facet)]);\n      }\n    }\n    return results;\n  })());\n  if (_.size(filters)) {\n    return {\n      terms: filters\n    };\n  } else {\n    return null;\n  }\n};\n\nbuildQueryFilter = function() {\n  var f, field, fields, i, len, parts, query, results, w, word, words;\n  query = State.select('filter', 'query').get();\n  if (query) {\n    words = (function() {\n      var i, len, ref, results;\n      ref = query.split(/\\s+/);\n      results = [];\n      for (i = 0, len = ref.length; i < len; i++) {\n        w = ref[i];\n        if (w !== '') {\n          results.push(w.toLowerCase());\n        }\n      }\n      return results;\n    })();\n    fields = State.select('query_fields').get();\n    parts = (function() {\n      var i, len, results;\n      results = [];\n      for (i = 0, len = words.length; i < len; i++) {\n        word = words[i];\n        results.push((function() {\n          var j, len1, obj, results1;\n          results1 = [];\n          for (j = 0, len1 = fields.length; j < len1; j++) {\n            field = fields[j];\n            results1.push({\n              prefix: (\n                obj = {},\n                obj[\"\" + field] = word,\n                obj\n              )\n            });\n          }\n          return results1;\n        })());\n      }\n      return results;\n    })();\n    results = [];\n    for (i = 0, len = parts.length; i < len; i++) {\n      w = parts[i];\n      results.push({\n        'or': (function() {\n          var j, len1, results1;\n          results1 = [];\n          for (j = 0, len1 = w.length; j < len1; j++) {\n            f = w[j];\n            results1.push(f);\n          }\n          return results1;\n        })()\n      });\n    }\n    return results;\n  } else {\n    return null;\n  }\n};\n\nbuildQuery = function() {\n  var f, filters;\n  filters = (function() {\n    var i, len, ref, results;\n    ref = _.flatten([buildQueryFilter(), buildFacetFilters()]);\n    results = [];\n    for (i = 0, len = ref.length; i < len; i++) {\n      f = ref[i];\n      if (f) {\n        results.push(f);\n      }\n    }\n    return results;\n  })();\n  if (filters.length) {\n    return {\n      constant_score: {\n        filter: {\n          and: filters\n        }\n      }\n    };\n  } else {\n    return {\n      match_all: {}\n    };\n  }\n};\n\nsearch = function() {\n  var query;\n  query = buildQuery();\n  return elastic.search({\n    index: 'ebisc',\n    type: 'cellline',\n    body: {\n      query: query,\n      size: 1000\n    }\n  }).then(function(body) {\n    return State.set('celllines', body.hits.hits);\n  }).error(function(error) {\n    return console.log(error);\n  });\n};\n\nState.select('filter').on('update', _.debounce(search, 100));\n\nmodule.exports = {\n  search: search\n};\n\n\n\n},{\"./state\":7}],7:[function(require,module,exports){\nvar Baobab, ReactAddons, options, state;\n\nBaobab = require('baobab');\n\nReactAddons = window.React.addons;\n\nstate = {\n  filter: {\n    query: '',\n    facets: [\n      {\n        name: 'celllineaccepted',\n        label: 'Accepted',\n        items: [\n          {\n            name: 'pending',\n            checked: false\n          }, {\n            name: 'accepted',\n            checked: false\n          }, {\n            name: 'rejected',\n            checked: false\n          }\n        ]\n      }, {\n        name: 'celllineprimarydisease',\n        label: 'Disease',\n        items: [\n          {\n            name: 'Control',\n            checked: false\n          }\n        ]\n      }\n    ]\n  },\n  celllines: []\n};\n\noptions = {\n  shiftReferences: true,\n  mixins: [ReactAddons.PureRenderMixin]\n};\n\nmodule.exports = new Baobab(state, options);\n\n\n\n},{\"baobab\":9}],8:[function(require,module,exports){\n/**\n * Baobab Default Options\n * =======================\n *\n */\nmodule.exports = {\n\n  // Should the tree handle its transactions on its own?\n  autoCommit: true,\n\n  // Should the transactions be handled asynchronously?\n  asynchronous: true,\n\n  // Should the tree clone data when giving it back to the user?\n  clone: false,\n\n  // Which cloning function should the tree use?\n  cloningFunction: null,\n\n  // Should cursors be singletons?\n  cursorSingletons: true,\n\n  // Maximum records in the tree's history\n  maxHistory: 0,\n\n  // Collection of react mixins to merge with the tree's ones\n  mixins: [],\n\n  // Should the tree shift its internal reference when applying mutations?\n  shiftReferences: false,\n\n  // Custom typology object to use along with the validation utilities\n  typology: null,\n\n  // Validation specifications\n  validate: null\n};\n\n},{}],9:[function(require,module,exports){\n/**\n * Baobab Public Interface\n * ========================\n *\n * Exposes the main library classes.\n */\nvar Baobab = require('./src/baobab.js'),\n    helpers = require('./src/helpers.js');\n\n// Non-writable version\nObject.defineProperty(Baobab, 'version', {\n  value: '0.4.3'\n});\n\n// Exposing helpers\nBaobab.getIn = helpers.getIn;\n\n// Exporting\nmodule.exports = Baobab;\n\n},{\"./src/baobab.js\":12,\"./src/helpers.js\":15}],10:[function(require,module,exports){\n(function() {\n  'use strict';\n\n  /**\n   * Here is the list of every allowed parameter when using Emitter#on:\n   * @type {Object}\n   */\n  var __allowedOptions = {\n    once: 'boolean',\n    scope: 'object'\n  };\n\n\n  /**\n   * The emitter's constructor. It initializes the handlers-per-events store and\n   * the global handlers store.\n   *\n   * Emitters are useful for non-DOM events communication. Read its methods\n   * documentation for more information about how it works.\n   *\n   * @return {Emitter}         The fresh new instance.\n   */\n  var Emitter = function() {\n    this._enabled = true;\n    this._children = [];\n    this._handlers = {};\n    this._handlersAll = [];\n  };\n\n\n  /**\n   * This method binds one or more functions to the emitter, handled to one or a\n   * suite of events. So, these functions will be executed anytime one related\n   * event is emitted.\n   *\n   * It is also possible to bind a function to any emitted event by not\n   * specifying any event to bind the function to.\n   *\n   * Recognized options:\n   * *******************\n   *  - {?boolean} once   If true, the handlers will be unbound after the first\n   *                      execution. Default value: false.\n   *  - {?object}  scope  If a scope is given, then the listeners will be called\n   *                      with this scope as \"this\".\n   *\n   * Variant 1:\n   * **********\n   * > myEmitter.on('myEvent', function(e) { console.log(e); });\n   * > // Or:\n   * > myEmitter.on('myEvent', function(e) { console.log(e); }, { once: true });\n   *\n   * @param  {string}   event   The event to listen to.\n   * @param  {function} handler The function to bind.\n   * @param  {?object}  options Eventually some options.\n   * @return {Emitter}          Returns this.\n   *\n   * Variant 2:\n   * **********\n   * > myEmitter.on(\n   * >   ['myEvent1', 'myEvent2'],\n   * >   function(e) { console.log(e); }\n   * >);\n   * > // Or:\n   * > myEmitter.on(\n   * >   ['myEvent1', 'myEvent2'],\n   * >   function(e) { console.log(e); }\n   * >   { once: true }}\n   * >);\n   *\n   * @param  {array}    events  The events to listen to.\n   * @param  {function} handler The function to bind.\n   * @param  {?object}  options Eventually some options.\n   * @return {Emitter}          Returns this.\n   *\n   * Variant 3:\n   * **********\n   * > myEmitter.on({\n   * >   myEvent1: function(e) { console.log(e); },\n   * >   myEvent2: function(e) { console.log(e); }\n   * > });\n   * > // Or:\n   * > myEmitter.on({\n   * >   myEvent1: function(e) { console.log(e); },\n   * >   myEvent2: function(e) { console.log(e); }\n   * > }, { once: true });\n   *\n   * @param  {object}  bindings An object containing pairs event / function.\n   * @param  {?object}  options Eventually some options.\n   * @return {Emitter}          Returns this.\n   *\n   * Variant 4:\n   * **********\n   * > myEmitter.on(function(e) { console.log(e); });\n   * > // Or:\n   * > myEmitter.on(function(e) { console.log(e); }, { once: true});\n   *\n   * @param  {function} handler The function to bind to every events.\n   * @param  {?object}  options Eventually some options.\n   * @return {Emitter}          Returns this.\n   */\n  Emitter.prototype.on = function(a, b, c) {\n    var i,\n        l,\n        k,\n        event,\n        eArray,\n        bindingObject;\n\n    // Variant 1 and 2:\n    if (typeof b === 'function') {\n      eArray = typeof a === 'string' ?\n        [a] :\n        a;\n\n      for (i = 0, l = eArray.length; i !== l; i += 1) {\n        event = eArray[i];\n\n        // Check that event is not '':\n        if (!event)\n          continue;\n\n        if (!this._handlers[event])\n          this._handlers[event] = [];\n\n        bindingObject = {\n          handler: b\n        };\n\n        for (k in c || {})\n          if (__allowedOptions[k])\n            bindingObject[k] = c[k];\n          else\n            throw new Error(\n              'The option \"' + k + '\" is not recognized by Emmett.'\n            );\n\n        this._handlers[event].push(bindingObject);\n      }\n\n    // Variant 3:\n    } else if (a && typeof a === 'object' && !Array.isArray(a))\n      for (event in a)\n        Emitter.prototype.on.call(this, event, a[event], b);\n\n    // Variant 4:\n    else if (typeof a === 'function') {\n      bindingObject = {\n        handler: a\n      };\n\n      for (k in c || {})\n        if (__allowedOptions[k])\n          bindingObject[k] = c[k];\n        else\n          throw new Error(\n            'The option \"' + k + '\" is not recognized by Emmett.'\n          );\n\n      this._handlersAll.push(bindingObject);\n    }\n\n    // No matching variant:\n    else\n      throw new Error('Wrong arguments.');\n\n    return this;\n  };\n\n\n  /**\n   * This method works exactly as the previous #on, but will add an options\n   * object if none is given, and set the option \"once\" to true.\n   *\n   * The polymorphism works exactly as with the #on method.\n   */\n  Emitter.prototype.once = function(a, b, c) {\n    // Variant 1 and 2:\n    if (typeof b === 'function') {\n      c = c || {};\n      c.once = true;\n      this.on(a, b, c);\n\n    // Variants 3 and 4:\n    } else if (\n      // Variant 3:\n      (a && typeof a === 'object' && !Array.isArray(a)) ||\n      // Variant 4:\n      (typeof a === 'function')\n    ) {\n      b = b || {};\n      b.once = true;\n      this.on(a, b);\n\n    // No matching variant:\n    } else\n      throw new Error('Wrong arguments.');\n\n    return this;\n  };\n\n\n  /**\n   * This method unbinds one or more functions from events of the emitter. So,\n   * these functions will no more be executed when the related events are\n   * emitted. If the functions were not bound to the events, nothing will\n   * happen, and no error will be thrown.\n   *\n   * Variant 1:\n   * **********\n   * > myEmitter.off('myEvent', myHandler);\n   *\n   * @param  {string}   event   The event to unbind the handler from.\n   * @param  {function} handler The function to unbind.\n   * @return {Emitter}          Returns this.\n   *\n   * Variant 2:\n   * **********\n   * > myEmitter.off(['myEvent1', 'myEvent2'], myHandler);\n   *\n   * @param  {array}    events  The events to unbind the handler from.\n   * @param  {function} handler The function to unbind.\n   * @return {Emitter}          Returns this.\n   *\n   * Variant 3:\n   * **********\n   * > myEmitter.off({\n   * >   myEvent1: myHandler1,\n   * >   myEvent2: myHandler2\n   * > });\n   *\n   * @param  {object} bindings An object containing pairs event / function.\n   * @return {Emitter}         Returns this.\n   *\n   * Variant 4:\n   * **********\n   * > myEmitter.off(myHandler);\n   *\n   * @param  {function} handler The function to unbind from every events.\n   * @return {Emitter}          Returns this.\n   */\n  Emitter.prototype.off = function(events, handler) {\n    var i,\n        n,\n        j,\n        m,\n        k,\n        a,\n        event,\n        eArray = typeof events === 'string' ?\n          [events] :\n          events;\n\n    if (arguments.length === 1 && typeof eArray === 'function') {\n      handler = arguments[0];\n\n      // Handlers bound to events:\n      for (k in this._handlers) {\n        a = [];\n        for (i = 0, n = this._handlers[k].length; i !== n; i += 1)\n          if (this._handlers[k][i].handler !== handler)\n            a.push(this._handlers[k][i]);\n        this._handlers[k] = a;\n      }\n\n      a = [];\n      for (i = 0, n = this._handlersAll.length; i !== n; i += 1)\n        if (this._handlersAll[i].handler !== handler)\n          a.push(this._handlersAll[i]);\n      this._handlersAll = a;\n    }\n\n    else if (arguments.length === 2) {\n      for (i = 0, n = eArray.length; i !== n; i += 1) {\n        event = eArray[i];\n        if (this._handlers[event]) {\n          a = [];\n          for (j = 0, m = this._handlers[event].length; j !== m; j += 1)\n            if (this._handlers[event][j].handler !== handler)\n              a.push(this._handlers[event][j]);\n\n          this._handlers[event] = a;\n        }\n\n        if (this._handlers[event] && this._handlers[event].length === 0)\n          delete this._handlers[event];\n      }\n    }\n\n    return this;\n  };\n\n\n  /**\n   * This method unbinds every handlers attached to every or any events. So,\n   * these functions will no more be executed when the related events are\n   * emitted. If the functions were not bound to the events, nothing will\n   * happen, and no error will be thrown.\n   *\n   * Usage:\n   * ******\n   * > myEmitter.unbindAll();\n   *\n   * @return {Emitter}      Returns this.\n   */\n  Emitter.prototype.unbindAll = function() {\n    var k;\n\n    this._handlersAll = [];\n    for (k in this._handlers)\n      delete this._handlers[k];\n\n    return this;\n  };\n\n\n  /**\n   * This method emits the specified event(s), and executes every handlers bound\n   * to the event(s).\n   *\n   * Use cases:\n   * **********\n   * > myEmitter.emit('myEvent');\n   * > myEmitter.emit('myEvent', myData);\n   * > myEmitter.emit(['myEvent1', 'myEvent2']);\n   * > myEmitter.emit(['myEvent1', 'myEvent2'], myData);\n   *\n   * @param  {string|array} events The event(s) to emit.\n   * @param  {object?}      data   The data.\n   * @return {Emitter}             Returns this.\n   */\n  Emitter.prototype.emit = function(events, data) {\n    var i,\n        n,\n        j,\n        m,\n        z,\n        a,\n        event,\n        child,\n        handlers,\n        eventName,\n        self = this,\n        eArray = typeof events === 'string' ?\n          [events] :\n          events;\n\n    // Check that the emitter is enabled:\n    if (!this._enabled)\n      return this;\n\n    data = data === undefined ? {} : data;\n\n    for (i = 0, n = eArray.length; i !== n; i += 1) {\n      eventName = eArray[i];\n      handlers = (this._handlers[eventName] || []).concat(this._handlersAll);\n\n      if (handlers.length) {\n        event = {\n          type: eventName,\n          data: data || {},\n          target: this\n        };\n        a = [];\n\n        for (j = 0, m = handlers.length; j !== m; j += 1) {\n\n          // We have to verify that the handler still exists in the array,\n          // as it might have been mutated already\n          if (\n            (\n              this._handlers[eventName] &&\n              this._handlers[eventName].indexOf(handlers[j]) >= 0\n            ) ||\n            this._handlersAll.indexOf(handlers[j]) >= 0\n          ) {\n            handlers[j].handler.call(\n              'scope' in handlers[j] ? handlers[j].scope : this,\n              event\n            );\n\n            // Since the listener callback can mutate the _handlers,\n            // we register the handlers we want to remove, not the ones\n            // we want to keep\n            if (handlers[j].once)\n              a.push(handlers[j]);\n          }\n        }\n\n        // Go through handlers to remove\n        for (z = 0; z < a.length; z++) {\n          this._handlers[eventName].splice(a.indexOf(a[z]), 1);\n        }\n      }\n    }\n\n    // Events propagation:\n    for (i = 0, n = this._children.length; i !== n; i += 1) {\n      child = this._children[i];\n      child.emit.apply(child, arguments);\n    }\n\n    return this;\n  };\n\n\n  /**\n   * This method creates a new instance of Emitter and binds it as a child. Here\n   * is what children do:\n   *  - When the parent emits an event, the children will emit the same later\n   *  - When a child is killed, it is automatically unreferenced from the parent\n   *  - When the parent is killed, all children will be killed as well\n   *\n   * @return {Emitter} Returns the fresh new child.\n   */\n  Emitter.prototype.child = function() {\n    var self = this,\n        child = new Emitter();\n\n    child.on('emmett:kill', function() {\n      if (self._children)\n        for (var i = 0, l = self._children.length; i < l; i++)\n          if (self._children[i] === child) {\n            self._children.splice(i, 1);\n            break;\n          }\n    });\n    this._children.push(child);\n\n    return child;\n  };\n\n  /**\n   * This returns an array of handler functions corresponding to the given\n   * event or every handler functions if an event were not to be given.\n   *\n   * @param  {?string} event Name of the event.\n   * @return {Emitter} Returns this.\n   */\n  function mapHandlers(a) {\n    var i, l, h = [];\n\n    for (i = 0, l = a.length; i < l; i++)\n      h.push(a[i].handler);\n\n    return h;\n  }\n\n  Emitter.prototype.listeners = function(event) {\n    var handlers = [],\n        k,\n        i,\n        l;\n\n    // If no event is passed, we return every handlers\n    if (!event) {\n      handlers = mapHandlers(this._handlersAll);\n\n      for (k in this._handlers)\n        handlers = handlers.concat(mapHandlers(this._handlers[k]));\n\n      // Retrieving handlers per children\n      for (i = 0, l = this._children.length; i < l; i++)\n        handlers = handlers.concat(this._children[i].listeners());\n    }\n\n    // Else we only retrieve the needed handlers\n    else {\n      handlers = mapHandlers(this._handlers[event]);\n\n      // Retrieving handlers per children\n      for (i = 0, l = this._children.length; i < l; i++)\n        handlers = handlers.concat(this._children[i].listeners(event));\n    }\n\n    return handlers;\n  };\n\n\n  /**\n   * This method will first dispatch a \"emmett:kill\" event, and then unbinds all\n   * listeners and make it impossible to ever rebind any listener to any event.\n   */\n  Emitter.prototype.kill = function() {\n    this.emit('emmett:kill');\n\n    this.unbindAll();\n    this._handlers = null;\n    this._handlersAll = null;\n    this._enabled = false;\n\n    if (this._children)\n      for (var i = 0, l = this._children.length; i < l; i++)\n        this._children[i].kill();\n\n    this._children = null;\n  };\n\n\n  /**\n   * This method disabled the emitter, which means its emit method will do\n   * nothing.\n   *\n   * @return {Emitter} Returns this.\n   */\n  Emitter.prototype.disable = function() {\n    this._enabled = false;\n\n    return this;\n  };\n\n\n  /**\n   * This method enables the emitter.\n   *\n   * @return {Emitter} Returns this.\n   */\n  Emitter.prototype.enable = function() {\n    this._enabled = true;\n\n    return this;\n  };\n\n\n  /**\n   * Version:\n   */\n  Emitter.version = '2.1.2';\n\n\n  // Export:\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports)\n      exports = module.exports = Emitter;\n    exports.Emitter = Emitter;\n  } else if (typeof define === 'function' && define.amd)\n    define('emmett', [], function() {\n      return Emitter;\n    });\n  else\n    this.Emitter = Emitter;\n}).call(this);\n\n},{}],11:[function(require,module,exports){\n/**\n * typology.js - A data validation library for Node.js and the browser,\n *\n * Version: 0.3.1\n * Sources: http://github.com/jacomyal/typology\n * Doc:     http://github.com/jacomyal/typology#readme\n *\n * License:\n * --------\n * Copyright © 2014 Alexis Jacomy (@jacomyal), Guillaume Plique (@Yomguithereal)\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * The Software is provided \"as is\", without warranty of any kind, express or\n * implied, including but not limited to the warranties of merchantability,\n * fitness for a particular purpose and noninfringement. In no event shall the\n * authors or copyright holders be liable for any claim, damages or other\n * liability, whether in an action of contract, tort or otherwise, arising\n * from, out of or in connection with the software or the use or other dealings\n * in the Software.\n */\n(function(global) {\n  'use strict';\n\n  /**\n   * Code conventions:\n   * *****************\n   *  - 80 characters max per line\n   *  - Write \"__myVar\" for any global private variable\n   *  - Write \"_myVar\" for any instance private variable\n   *  - Write \"myVar\" any local variable\n   */\n\n\n\n  /**\n   * PRIVATE GLOBALS:\n   * ****************\n   */\n\n  /**\n   * This object is a dictionnary that maps \"[object Something]\" strings to the\n   * typology form \"something\":\n   */\n  var __class2type = {};\n\n  /**\n   * This array is the list of every types considered native by typology:\n   */\n  var __nativeTypes = ['*'];\n\n  (function() {\n    var k,\n        className,\n        classes = [\n          'Arguments',\n          'Boolean',\n          'Number',\n          'String',\n          'Function',\n          'Array',\n          'Date',\n          'RegExp',\n          'Object'\n        ];\n\n    // Fill types\n    for (k in classes) {\n      className = classes[k];\n      __nativeTypes.push(className.toLowerCase());\n      __class2type['[object ' + className + ']'] = className.toLowerCase();\n    }\n  })();\n\n\n\n  /**\n   * CONSTRUCTOR:\n   * ************\n   */\n  function Typology(defs) {\n    /**\n     * INSTANCE PRIVATES:\n     * ******************\n     */\n\n    var _self = this;\n\n    /**\n     * This objects will contain every instance-specific custom types:\n     */\n    var _customTypes = {};\n\n    /**\n     * This function will recursively scan an object to check wether or not it\n     * matches a given type. It will return null if it matches, and an Error\n     * object else.\n     *\n     * Examples:\n     * *********\n     * 1. When the type matches:\n     *  > _scan('abc', 'string');\n     *  will return null.\n     *\n     * 2. When a top-level type does not match:\n     *  > _scan('abc', 'number');\n     *  will return an Error object with the following information:\n     *   - message: Expected a \"number\" but found a \"string\".\n     *\n     * 3. When a sub-object type does not its type:\n     *  > _scan({ a: 'abc' }, { a: 'number' });\n     *  will return an Error object with the following information:\n     *   - message: Expected a \"number\" but found a \"string\".\n     *   - path: [ 'a' ]\n     *\n     * 4. When a deep sub-object type does not its type:\n     *  > _scan({ a: [ 123, 'abc' ] }, { a: ['number'] });\n     *  will return an Error object with the following information:\n     *   - message: Expected a \"number\" but found a \"string\".\n     *   - path: [ 'a', 1 ]\n     *\n     * 5. When a required key is missing:\n     *  > _scan({}, { a: 'number' });\n     *  will return an Error object with the following information:\n     *   - message: Expected a \"number\" but found a \"undefined\".\n     *   - path: [ 'a' ]\n     *\n     * 6. When an unexpected key is present:\n     *  > _scan({ a: 123, b: 456 }, { a: 'number' });\n     *  will return an Error object with the following information:\n     *   - message: Unexpected key \"b\".\n     *\n     * @param  {*}      obj  The value to validate.\n     * @param  {type}   type The type.\n     * @return {?Error}      Returns null or an Error object.\n     */\n    function _scan(obj, type) {\n      var a,\n          i,\n          l,\n          k,\n          error,\n          subError,\n          hasStar,\n          hasTypeOf,\n          optional = false,\n          exclusive = false,\n          typeOf = _self.get(obj);\n\n      if (_self.get(type) === 'string') {\n        a = type.replace(/^[\\?\\!]/, '').split(/\\|/);\n        l = a.length;\n        for (i = 0; i < l; i++)\n          if (__nativeTypes.indexOf(a[i]) < 0 && !(a[i] in _customTypes))\n            throw new Error('Invalid type.');\n\n        if (type.match(/^\\?/))\n          optional = true;\n\n        if (type.replace(/^\\?/, '').match(/^\\!/))\n          exclusive = true;\n\n        if (exclusive && optional)\n          throw new Error('Invalid type.');\n\n        for (i in a)\n          if (_customTypes[a[i]])\n            if (\n              (typeof _customTypes[a[i]].type === 'function') ?\n                (_customTypes[a[i]].type.call(_self, obj) === true) :\n                !_scan(obj, _customTypes[a[i]].type)\n            ) {\n              if (exclusive) {\n                error = new Error();\n                error.message = 'Expected a \"' + type + '\" but found a ' +\n                                '\"' + a[i] + '\".';\n              error.expected = type;\n              error.type = a[i];\n              error.value = obj;\n                return error;\n              } else\n                return null;\n            }\n\n        if (obj === null || obj === undefined) {\n          if (!exclusive && !optional) {\n            error = new Error();\n            error.message = 'Expected a \"' + type + '\" but found a ' +\n                            '\"' + typeOf + '\".';\n            error.expected = type;\n            error.type = typeOf;\n            error.value = obj;\n            return error;\n          } else\n            return null;\n\n        } else {\n          hasStar = ~a.indexOf('*');\n          hasTypeOf = ~a.indexOf(typeOf);\n          if (exclusive && (hasStar || hasTypeOf)) {\n            error = new Error();\n            error.message = 'Expected a \"' + type + '\" but found a ' +\n                            '\"' + (hasTypeOf ? typeOf : '*') + '\".';\n            error.type = hasTypeOf ? typeOf : '*';\n            error.expected = type;\n            error.value = obj;\n            return error;\n\n          } else if (!exclusive && !(hasStar || hasTypeOf)) {\n            error = new Error();\n            error.message = 'Expected a \"' + type + '\" but found a ' +\n                            '\"' + typeOf + '\".';\n            error.expected = type;\n            error.type = typeOf;\n            error.value = obj;\n            return error;\n\n          } else\n            return null;\n        }\n\n      } else if (_self.get(type) === 'object') {\n        if (typeOf !== 'object') {\n          error = new Error();\n          error.message = 'Expected an object but found a \"' + typeOf + '\".';\n          error.expected = type;\n          error.type = typeOf;\n          error.value = obj;\n          return error;\n        }\n\n        for (k in type)\n          if ((subError = _scan(obj[k], type[k]))) {\n            error = subError;\n            error.path = error.path ?\n              [k].concat(error.path) :\n              [k];\n            return error;\n          }\n\n        for (k in obj)\n          if (type[k] === undefined) {\n            error = new Error();\n            error.message = 'Unexpected key \"' + k + '\".';\n            error.type = typeOf;\n            error.value = obj;\n            return error;\n          }\n\n        return null;\n\n      } else if (_self.get(type) === 'array') {\n        if (type.length !== 1)\n          throw new Error('Invalid type.');\n\n        if (typeOf !== 'array') {\n          error = new Error();\n          error.message = 'Expected an array but found a \"' + typeOf + '\".';\n          error.expected = type;\n          error.type = typeOf;\n          error.value = obj;\n          return error;\n        }\n\n        l = obj.length;\n        for (i = 0; i < l; i++)\n          if ((subError = _scan(obj[i], type[0]))) {\n            error = subError;\n            error.path = error.path ?\n              [i].concat(error.path) :\n              [i];\n            return error;\n          }\n\n        return null;\n      } else\n        throw new Error('Invalid type.');\n    }\n\n\n\n    /**\n     * INSTANCE METHODS:\n     * *****************\n     */\n\n    /**\n     * This method registers a custom type into the Typology instance. A type\n     * is registered under a unique name, and is described by an object (like\n     * classical C structures) or a function.\n     *\n     * Variant 1:\n     * **********\n     * > types.add('user', { id: 'string', name: '?string' });\n     *\n     * @param  {string}   id   The unique id of the type.\n     * @param  {object}   type The corresponding structure.\n     * @return {Typology}      Returns this.\n     *\n     * Variant 2:\n     * **********\n     * > types.add('integer', function(value) {\n     * >   return typeof value === 'number' && value === value | 0;\n     * > });\n     *\n     * @param  {string}   id   The unique id of the type.\n     * @param  {function} type The function validating the type.\n     * @return {Typology}      Returns this.\n     *\n     * Variant 3:\n     * **********\n     * > types.add({\n     * >   id: 'user',\n     * >   type: { id: 'string', name: '?string' }\n     * > });\n     *\n     * > types.add({\n     * >   id: 'integer',\n     * >   type: function(value) {\n     * >     return typeof value === 'number' && value === value | 0;\n     * >   }\n     * > });\n     *\n     * @param  {object}   specs An object describing fully the type.\n     * @return {Typology}       Returns this.\n     *\n     * Recognized parameters:\n     * **********************\n     * Here is the exhaustive list of every accepted parameters in the specs\n     * object:\n     *\n     *   {string}          id    The unique id of the type.\n     *   {function|object} type  The function or the structure object\n     *                           validating the type.\n     *   {?[string]}       proto Eventually an array of ids of types that are\n     *                           referenced in the structure but do not exist\n     *                           yet.\n     */\n    this.add = function(a1, a2) {\n      var o,\n          k,\n          a,\n          id,\n          tmp,\n          type;\n\n      // Polymorphism:\n      if (arguments.length === 1) {\n        if (this.get(a1) === 'object') {\n          o = a1;\n          id = o.id;\n          type = o.type;\n        } else\n          throw new Error('If types.add is called with one argument, ' +\n                          'this one has to be an object.');\n      } else if (arguments.length === 2) {\n        if (typeof a1 !== 'string' || !a1)\n          throw new Error('If types.add is called with more than one ' +\n                          'argument, the first one must be the string id.');\n        else\n          id = a1;\n\n        type = a2;\n      } else\n        throw new Error('types.add has to be called ' +\n                        'with one or two arguments.');\n\n      if (this.get(id) !== 'string' || id.length === 0)\n        throw new Error('A type requires an string id.');\n\n      if (_customTypes[id] !== undefined && _customTypes[id] !== 'proto')\n        throw new Error('The type \"' + id + '\" already exists.');\n\n      if (~__nativeTypes.indexOf(id))\n        throw new Error('\"' + id + '\" is a reserved type name.');\n\n      _customTypes[id] = 1;\n\n      // Check given prototypes:\n      a = (o || {}).proto || [];\n      a = Array.isArray(a) ? a : [a];\n      tmp = {};\n      for (k in a)\n        if (_customTypes[a[k]] === undefined) {\n          _customTypes[a[k]] = 1;\n          tmp[a[k]] = 1;\n        }\n\n      if ((this.get(type) !== 'function') && !this.isValid(type))\n        throw new Error('A type requires a valid definition. ' +\n                        'This one can be a preexistant type or else ' +\n                        'a function testing given objects.');\n\n      // Effectively add the type:\n      _customTypes[id] = (o === undefined) ?\n        {\n          id: id,\n          type: type\n        } :\n        {};\n\n      if (o !== undefined)\n        for (k in o)\n          _customTypes[id][k] = o[k];\n\n      // Delete prototypes:\n      for (k in tmp)\n        if (k !== id)\n          delete _customTypes[k];\n\n      return this;\n    };\n\n    /**\n     * This method returns true if a custom type is already registered in this\n     * instance under the given key.\n     *\n     * @param  {string}  key A type name.\n     * @return {boolean}     Returns true if the key is registered.\n     */\n    this.has = function(key) {\n      return !!_customTypes[key];\n    };\n\n    /**\n     * This method returns the native type of a given value.\n     *\n     * Examples:\n     * *********\n     * > types.get({ a: 1 }); // returns \"object\"\n     * > types.get('abcde');  // returns \"string\"\n     * > types.get(1234567);  // returns \"number\"\n     * > types.get([1, 2]);   // returns \"array\"\n     *\n     * @param  {*}      value Anything.\n     * @return {string}       Returns the native type of the value.\n     */\n    this.get = function(obj) {\n      return (obj === null || obj === undefined) ?\n        String(obj) :\n        __class2type[Object.prototype.toString.call(obj)] || 'object';\n    };\n\n    /**\n     * This method validates some value against a given type. If the flag throws\n     * has a truthy value, then the method will throw an error instead of\n     * returning false.\n     *\n     * To know more about the error thrown, you can read the documentation of\n     * the private method _scan.\n     *\n     * Examples:\n     * *********\n     * > types.check({ a: 1 }, 'object');                      // returns true\n     * > types.check({ a: 1 }, { a: 'string' });               // returns true\n     * > types.check({ a: 1 }, { a: 'string', b: '?number' }); // returns true\n     *\n     * > types.check({ a: 1 }, { a: 'string', b: 'number' }); // returns false\n     * > types.check({ a: 1 }, { a: 'number' });              // returns false\n     * > types.check({ a: 1 }, 'array');                      // returns false\n     *\n     * > types.check({ a: 1 }, 'array', true); // throws an Error\n     *\n     * @param  {*}        value  Anything.\n     * @param  {type}     type   A valid type.\n     * @param  {?boolean} throws If true, this method will throw an error\n     *                           instead of returning false.\n     * @return {boolean}         Returns true if the value matches the type, and\n     *                           not else.\n     */\n    this.check = function(obj, type, throws) {\n      var result = _scan(obj, type);\n      if (throws && result)\n        throw result;\n      else\n        return !result;\n    };\n\n    /**\n     * This method validates a type. If the type is not referenced or is not\n     * valid, it will return false.\n     *\n     * To know more about that function, don't hesitate to read the related\n     * unit tests.\n     *\n     * Examples:\n     * *********\n     * > types.isValid('string');        // returns true\n     * > types.isValid('?string');       // returns true\n     * > types.isValid('!string');       // returns true\n     * > types.isValid('string|number'); // returns true\n     * > types.isValid({ a: 'string' }); // returns true\n     * > types.isValid(['string']);      // returns true\n     *\n     * > types.isValid('!?string');                // returns false\n     * > types.isValid('myNotDefinedType');        // returns false\n     * > types.isValid(['myNotDefinedType']);      // returns false\n     * > types.isValid({ a: 'myNotDefinedType' }); // returns false\n     *\n     * > types.isValid('user');               // returns false\n     * > types.add('user', { id: 'string' }); // makes the type become valid\n     * > types.isValid('user');               // returns true\n     *\n     * @param  {*}       type The type to get checked.\n     * @return {boolean}      Returns true if the type is valid, and false else.\n     */\n    this.isValid = function(type) {\n      var a,\n          k,\n          i;\n\n      if (this.get(type) === 'string') {\n        a = type.replace(/^[\\?\\!]/, '').split(/\\|/);\n        for (i in a)\n          if (__nativeTypes.indexOf(a[i]) < 0 && !(a[i] in _customTypes))\n            return false;\n        return true;\n\n      } else if (this.get(type) === 'object') {\n        for (k in type)\n          if (!this.isValid(type[k]))\n            return false;\n        return true;\n\n      } else if (this.get(type) === 'array')\n        return type.length === 1 ?\n          this.isValid(type[0]) :\n          false;\n      else\n        return false;\n    };\n\n\n\n    /**\n     * INSTANTIATION ROUTINE:\n     * **********************\n     */\n\n    // Add a type \"type\" to shortcut the #isValid method:\n    this.add('type', (function(v) {\n      return this.isValid(v);\n    }).bind(this));\n\n    // Add a type \"primitive\" to match every primitive types (including null):\n    this.add('primitive', function(v) {\n      return !v || !(v instanceof Object || typeof v === 'object');\n    });\n\n    // Adding custom types at instantiation:\n    defs = defs || {};\n    if (this.get(defs) !== 'object')\n      throw Error('Invalid argument.');\n\n    for (var k in defs)\n      this.add(k, defs[k]);\n  }\n\n\n\n  /**\n   * GLOBAL PUBLIC API:\n   * ******************\n   */\n\n  // Creating a \"main\" typology instance to export:\n  var types = Typology;\n  Typology.call(types);\n\n  // Version:\n  Object.defineProperty(types, 'version', {\n    value: '0.3.1'\n  });\n\n\n\n  /**\n   * EXPORT:\n   * *******\n   */\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports)\n      exports = module.exports = types;\n    exports.types = types;\n  } else if (typeof define === 'function' && define.amd)\n    define('typology', [], function() {\n      return types;\n    });\n  else\n    this.types = types;\n})(this);\n\n},{}],12:[function(require,module,exports){\n/**\n * Baobab Data Structure\n * ======================\n *\n * A handy data tree with cursors.\n */\nvar Cursor = require('./cursor.js'),\n    EventEmitter = require('emmett'),\n    Typology = require('typology'),\n    helpers = require('./helpers.js'),\n    update = require('./update.js'),\n    merge = require('./merge.js'),\n    mixins = require('./mixins.js'),\n    defaults = require('../defaults.js'),\n    type = require('./type.js');\n\nfunction complexHash(type) {\n  return type + '$' +\n    (new Date()).getTime() + (''  + Math.random()).replace('0.', '');\n}\n\n/**\n * Main Class\n */\nfunction Baobab(initialData, opts) {\n  if (arguments.length < 1)\n    initialData = {};\n\n  // New keyword optional\n  if (!(this instanceof Baobab))\n    return new Baobab(initialData, opts);\n\n  if (!type.Object(initialData) && !type.Array(initialData))\n    throw Error('Baobab: invalid data.');\n\n  // Extending\n  EventEmitter.call(this);\n\n  // Merging defaults\n  this.options = helpers.shallowMerge(defaults, opts);\n  this._cloner = this.options.cloningFunction || helpers.deepClone;\n\n  // Privates\n  this._transaction = {};\n  this._future = undefined;\n  this._history = [];\n  this._cursors = {};\n\n  // Internal typology\n  this.typology = this.options.typology ?\n    (this.options.typology instanceof Typology ?\n      this.options.typology :\n      new Typology(this.options.typology)) :\n    new Typology();\n\n  // Internal validation\n  this.validate = this.options.validate || null;\n\n  if (this.validate)\n    try {\n      this.typology.check(initialData, this.validate, true);\n    }\n    catch (e) {\n      e.message = '/' + e.path.join('/') + ': ' + e.message;\n      throw e;\n    }\n\n  // Properties\n  this.data = this._cloner(initialData);\n\n  // Mixin\n  this.mixin = mixins.baobab(this);\n}\n\nhelpers.inherits(Baobab, EventEmitter);\n\n/**\n * Private prototype\n */\nBaobab.prototype._archive = function() {\n  if (this.options.maxHistory <= 0)\n    return;\n\n  var record = {\n    data: this._cloner(this.data)\n  };\n\n  // Replacing\n  if (this._history.length === this.options.maxHistory) {\n    this._history.pop();\n  }\n  this._history.unshift(record);\n\n  return record;\n};\n\n/**\n * Prototype\n */\nBaobab.prototype.commit = function(referenceRecord) {\n  var self = this,\n      log;\n\n  if (referenceRecord) {\n\n    // Override\n    this.data = referenceRecord.data;\n    log = referenceRecord.log;\n  }\n  else {\n\n    // Shifting root reference\n    if (this.options.shiftReferences)\n      this.data = helpers.shallowClone(this.data);\n\n    // Applying modification (mutation)\n    var record = this._archive();\n    log = update(this.data, this._transaction, this.options);\n\n    if (record)\n      record.log = log;\n  }\n\n  if (this.validate) {\n    var errors = [],\n        l = log.length,\n        d,\n        i;\n\n    for (i = 0; i < l; i++) {\n      d = helpers.getIn(this.validate, log[i]);\n\n      if (!d)\n        continue;\n\n      try {\n        this.typology.check(this.get(log[i]), d, true);\n      }\n      catch (e) {\n        e.path = log[i].concat((e.path || []));\n        errors.push(e);\n      }\n    }\n\n    if (errors.length)\n      this.emit('invalid', {errors: errors});\n  }\n\n  // Resetting\n  this._transaction = {};\n\n  if (this._future)\n    this._future = clearTimeout(this._future);\n\n  // Baobab-level update event\n  this.emit('update', {\n    log: log\n  });\n\n  return this;\n};\n\nBaobab.prototype.select = function(path) {\n  if (arguments.length > 1)\n    path = helpers.arrayOf(arguments);\n\n  if (!type.Path(path))\n    throw Error('Baobab.select: invalid path.');\n\n  // Casting to array\n  path = !type.Array(path) ? [path] : path;\n\n  // Complex path?\n  var complex = type.ComplexPath(path);\n\n  var solvedPath;\n\n  if (complex)\n    solvedPath = helpers.solvePath(this.data, path);\n\n  // Registering a new cursor or giving the already existing one for path\n  if (!this.options.cursorSingletons) {\n    return new Cursor(this, path);\n  }\n  else {\n    var hash = path.map(function(step) {\n      if (type.Function(step))\n        return complexHash('fn');\n      else if (type.Object(step))\n        return complexHash('ob');\n      else\n        return step;\n    }).join('λ');\n\n    if (!this._cursors[hash]) {\n      var cursor = new Cursor(this, path, solvedPath, hash);\n      this._cursors[hash] = cursor;\n      return cursor;\n    }\n    else {\n      return this._cursors[hash];\n    }\n  }\n};\n\nBaobab.prototype.root = function() {\n  return this.select();\n};\n\nBaobab.prototype.reference = function(path) {\n  var data;\n\n  if (arguments.length > 1)\n    path = helpers.arrayOf(arguments);\n\n  if (!type.Path(path))\n    throw Error('Baobab.get: invalid path.');\n\n  return helpers.getIn(\n    this.data, type.String(path) || type.Number(path) ? [path] : path\n  );\n};\n\nBaobab.prototype.get = function() {\n  var ref = this.reference.apply(this, arguments);\n\n  return this.options.clone ? this._cloner(ref) : ref;\n};\n\nBaobab.prototype.clone = function(path) {\n  return this._cloner(this.reference.apply(this, arguments));\n};\n\nBaobab.prototype.set = function(key, val) {\n\n  if (arguments.length < 2)\n    throw Error('Baobab.set: expects a key and a value.');\n\n  var spec = {};\n\n  if (type.Array(key)) {\n    var path = helpers.solvePath(this.data, key);\n\n    if (!path)\n      throw Error('Baobab.set: could not solve dynamic path.');\n\n    spec = helpers.pathObject(path, {$set: val});\n  }\n  else {\n    spec[key] = {$set: val};\n  }\n\n  return this.update(spec);\n};\n\nBaobab.prototype.unset = function(key) {\n  if (!key && key !== 0)\n    throw Error('Baobab.unset: expects a valid key to unset.');\n\n  var spec = {};\n  spec[key] = {$unset: true};\n\n  return this.update(spec);\n};\n\nBaobab.prototype.update = function(spec) {\n  var self = this;\n\n  if (!type.Object(spec))\n    throw Error('Baobab.update: wrong specification.');\n\n  this._transaction = merge(spec, this._transaction);\n\n  // Should we let the user commit?\n  if (!this.options.autoCommit)\n    return this;\n\n  // Should we update synchronously?\n  if (!this.options.asynchronous)\n    return this.commit();\n\n  // Updating asynchronously\n  if (!this._future)\n    this._future = setTimeout(self.commit.bind(self, null), 0);\n\n  return this;\n};\n\nBaobab.prototype.hasHistory = function() {\n  return !!this._history.length;\n};\n\nBaobab.prototype.getHistory = function() {\n  return this._history;\n};\n\nBaobab.prototype.undo = function() {\n  if (!this.hasHistory())\n    throw Error('Baobab.undo: no history recorded, cannot undo.');\n\n  var lastRecord = this._history.shift();\n  this.commit(lastRecord);\n};\n\nBaobab.prototype.release = function() {\n\n  delete this.data;\n  delete this._transaction;\n  delete this._history;\n\n  // Releasing cursors\n  for (var k in this._cursors)\n    this._cursors[k].release();\n  delete this._cursors;\n\n  // Killing event emitter\n  this.kill();\n};\n\n/**\n * Output\n */\nBaobab.prototype.toJSON = function() {\n  return this.reference();\n};\n\n/**\n * Export\n */\nmodule.exports = Baobab;\n\n},{\"../defaults.js\":8,\"./cursor.js\":14,\"./helpers.js\":15,\"./merge.js\":16,\"./mixins.js\":17,\"./type.js\":18,\"./update.js\":19,\"emmett\":10,\"typology\":11}],13:[function(require,module,exports){\n/**\n * Baobab Cursor Combination\n * ==========================\n *\n * A useful abstraction dealing with cursor's update logical combinations.\n */\nvar EventEmitter = require('emmett'),\n    helpers = require('./helpers.js'),\n    type = require('./type.js');\n\n/**\n * Utilities\n */\nfunction bindCursor(c, cursor) {\n  cursor.on('update', c.cursorListener);\n  c.tree.off('update', c.treeListener);\n  c.tree.on('update', c.treeListener);\n}\n\n/**\n * Main Class\n */\nfunction Combination(operator /*, &cursors */) {\n  var self = this;\n\n  // Safeguard\n  if (arguments.length < 2)\n    throw Error('baobab.Combination: not enough arguments.');\n\n  var first = arguments[1],\n      rest = helpers.arrayOf(arguments).slice(2);\n\n  if (first instanceof Array) {\n    rest = first.slice(1);\n    first = first[0];\n  }\n\n  if (!type.Cursor(first))\n    throw Error('baobab.Combination: argument should be a cursor.');\n\n  if (operator !== 'or' && operator !== 'and')\n    throw Error('baobab.Combination: invalid operator.');\n\n  // Extending event emitter\n  EventEmitter.call(this);\n\n  // Properties\n  this.cursors = [first];\n  this.operators = [];\n  this.tree = first.tree;\n\n  // State\n  this.updates = new Array(this.cursors.length);\n\n  // Listeners\n  this.cursorListener = function() {\n    self.updates[self.cursors.indexOf(this)] = true;\n  };\n\n  this.treeListener = function() {\n    var shouldFire = self.updates[0],\n        i,\n        l;\n\n    for (i = 1, l = self.cursors.length; i < l; i++) {\n      shouldFire = self.operators[i - 1] === 'or' ?\n        shouldFire || self.updates[i] :\n        shouldFire && self.updates[i];\n    }\n\n    if (shouldFire)\n      self.emit('update');\n\n    // Waiting for next update\n    self.updates = new Array(self.cursors.length);\n  };\n\n  // Lazy binding\n  this.bound = false;\n\n  var regularOn = this.on,\n      regularOnce = this.once;\n\n  var lazyBind = function() {\n    if (self.bound)\n      return;\n    self.bound = true;\n    self.cursors.forEach(function(cursor) {\n      bindCursor(self, cursor);\n    });\n  };\n\n  this.on = function() {\n    lazyBind();\n    return regularOn.apply(this, arguments);\n  };\n\n  this.once = function() {\n    lazyBind();\n    return regularOnce.apply(this, arguments);\n  };\n\n  // Attaching any other passed cursors\n  rest.forEach(function(cursor) {\n    this[operator](cursor);\n  }, this);\n}\n\nhelpers.inherits(Combination, EventEmitter);\n\n/**\n * Prototype\n */\nfunction makeOperator(operator) {\n  Combination.prototype[operator] = function(cursor) {\n\n    // Safeguard\n    if (!type.Cursor(cursor)) {\n      this.release();\n      throw Error('baobab.Combination.' + operator + ': argument should be a cursor.');\n    }\n\n    if (~this.cursors.indexOf(cursor)) {\n      this.release();\n      throw Error('baobab.Combination.' + operator + ': cursor already in combination.');\n    }\n\n    this.cursors.push(cursor);\n    this.operators.push(operator);\n    this.updates.length++;\n\n    if (this.bound)\n      bindCursor(this, cursor);\n\n    return this;\n  };\n}\n\nmakeOperator('or');\nmakeOperator('and');\n\nCombination.prototype.release = function() {\n\n  // Dropping cursors listeners\n  this.cursors.forEach(function(cursor) {\n    cursor.off('update', this.cursorListener);\n  }, this);\n\n  // Dropping tree listener\n  this.tree.off('update', this.treeListener);\n\n  // Cleaning\n  this.cursors = null;\n  this.operators = null;\n  this.tree = null;\n  this.updates = null;\n\n  // Dropping own listeners\n  this.kill();\n};\n\n/**\n * Exporting\n */\nmodule.exports = Combination;\n\n},{\"./helpers.js\":15,\"./type.js\":18,\"emmett\":10}],14:[function(require,module,exports){\n/**\n * Baobab Cursor Abstraction\n * ==========================\n *\n * Nested selection into a baobab tree.\n */\nvar EventEmitter = require('emmett'),\n    Combination = require('./combination.js'),\n    mixins = require('./mixins.js'),\n    helpers = require('./helpers.js'),\n    type = require('./type.js');\n\n/**\n * Main Class\n */\nfunction Cursor(tree, path, solvedPath, hash) {\n  var self = this;\n\n  // Extending event emitter\n  EventEmitter.call(this);\n\n  // Enforcing array\n  path = path || [];\n\n  // Properties\n  this.tree = tree;\n  this.path = path;\n  this.hash = hash;\n  this.relevant = this.reference() !== undefined;\n\n  // Complex path?\n  this.complexPath = !!solvedPath;\n  this.solvedPath = this.complexPath ? solvedPath : this.path;\n\n  // Root listeners\n  this.updateHandler = function(e) {\n    var log = e.data.log,\n        shouldFire = false,\n        c, p, l, m, i, j;\n\n    // Solving path if needed\n    if (self.complexPath)\n      self.solvedPath = helpers.solvePath(self.tree.data, self.path);\n\n    // If selector listens at tree, we fire\n    if (!self.path.length)\n      return self.emit('update');\n\n    // Checking update log to see whether the cursor should update.\n    outer:\n    for (i = 0, l = log.length; i < l; i++) {\n      c = log[i];\n\n      for (j = 0, m = c.length; j < m; j++) {\n        p = c[j];\n\n        // If path is not relevant to us, we break\n        if (p !== '' + self.solvedPath[j])\n          break;\n\n        // If we reached last item and we are relevant, we fire\n        if (j + 1 === m || j + 1 === self.solvedPath.length) {\n          shouldFire = true;\n          break outer;\n        }\n      }\n    }\n\n    // Handling relevancy\n    var data = self.reference() !== undefined;\n\n    if (self.relevant) {\n      if (data && shouldFire) {\n        self.emit('update');\n      }\n      else if (!data) {\n        self.emit('irrelevant');\n        self.relevant = false;\n      }\n    }\n    else {\n      if (data && shouldFire) {\n        self.emit('relevant');\n        self.emit('update');\n        self.relevant = true;\n      }\n    }\n  };\n\n  // Making mixin\n  this.mixin = mixins.cursor(this);\n\n  // Lazy binding\n  var bound = false,\n      regularOn = this.on,\n      regularOnce = this.once;\n\n  var lazyBind = function() {\n    if (bound)\n      return;\n    bound = true;\n    self.tree.on('update', self.updateHandler);\n  };\n\n  this.on = function() {\n    lazyBind();\n    return regularOn.apply(this, arguments);\n  };\n\n  this.once = function() {\n    lazyBind();\n    return regularOnce.apply(this, arguments);\n  };\n}\n\nhelpers.inherits(Cursor, EventEmitter);\n\n/**\n * Predicates\n */\nCursor.prototype.isRoot = function() {\n  return !this.path.length;\n};\n\nCursor.prototype.isLeaf = function() {\n  return type.Primitive(this.reference());\n};\n\nCursor.prototype.isBranch = function() {\n  return !this.isLeaf() && !this.isRoot();\n};\n\n/**\n * Traversal\n */\nCursor.prototype.root = function() {\n  return this.tree.root();\n};\n\nCursor.prototype.select = function(path) {\n  if (arguments.length > 1)\n    path = helpers.arrayOf(arguments);\n\n  if (!type.Path(path))\n    throw Error('baobab.Cursor.select: invalid path.');\n  return this.tree.select(this.path.concat(path));\n};\n\nCursor.prototype.up = function() {\n  if (this.solvedPath && this.solvedPath.length)\n    return this.tree.select(this.path.slice(0, -1));\n  else\n    return null;\n};\n\nCursor.prototype.left = function() {\n  var last = +this.solvedPath[this.solvedPath.length - 1];\n\n  if (isNaN(last))\n    throw Error('baobab.Cursor.left: cannot go left on a non-list type.');\n\n  return last ?\n    this.tree.select(this.solvedPath.slice(0, -1).concat(last - 1)) :\n    null;\n};\n\nCursor.prototype.leftmost = function() {\n  var last = +this.solvedPath[this.solvedPath.length - 1];\n\n  if (isNaN(last))\n    throw Error('baobab.Cursor.leftmost: cannot go left on a non-list type.');\n\n  return this.tree.select(this.solvedPath.slice(0, -1).concat(0));\n};\n\nCursor.prototype.right = function() {\n  var last = +this.solvedPath[this.solvedPath.length - 1];\n\n  if (isNaN(last))\n    throw Error('baobab.Cursor.right: cannot go right on a non-list type.');\n\n  if (last + 1 === this.up().reference().length)\n    return null;\n\n  return this.tree.select(this.solvedPath.slice(0, -1).concat(last + 1));\n};\n\nCursor.prototype.rightmost = function() {\n  var last = +this.solvedPath[this.solvedPath.length - 1];\n\n  if (isNaN(last))\n    throw Error('baobab.Cursor.right: cannot go right on a non-list type.');\n\n  var list = this.up().reference();\n\n  return this.tree.select(this.solvedPath.slice(0, -1).concat(list.length - 1));\n};\n\nCursor.prototype.down = function() {\n  var last = +this.solvedPath[this.solvedPath.length - 1];\n\n  if (!(this.reference() instanceof Array))\n    return null;\n\n  return this.tree.select(this.solvedPath.concat(0));\n};\n\n/**\n * Access\n */\nCursor.prototype.get = function(path) {\n  if (arguments.length > 1)\n    path = helpers.arrayOf(arguments);\n\n  if (type.Step(path))\n    return this.tree.get(this.solvedPath.concat(path));\n  else\n    return this.tree.get(this.solvedPath);\n};\n\nCursor.prototype.reference = function(path) {\n  if (arguments.length > 1)\n    path = helpers.arrayOf(arguments);\n\n  if (type.Step(path))\n    return this.tree.reference(this.solvedPath.concat(path));\n  else\n    return this.tree.reference(this.solvedPath);\n};\n\nCursor.prototype.clone = function(path) {\n  if (arguments.length > 1)\n    path = helpers.arrayOf(arguments);\n\n  if (type.Step(path))\n    return this.tree.clone(this.solvedPath.concat(path));\n  else\n    return this.tree.clone(this.solvedPath);\n};\n\n/**\n * Update\n */\nCursor.prototype.set = function(key, val) {\n  if (arguments.length < 2)\n    throw Error('baobab.Cursor.set: expecting at least key/value.');\n\n  var data = this.reference();\n\n  if (typeof data !== 'object')\n    throw Error('baobab.Cursor.set: trying to set key to a non-object.');\n\n  var spec = {};\n\n  if (type.Array(key)) {\n    var path = helpers.solvePath(data, key);\n\n    if (!path)\n      throw Error('baobab.Cursor.set: could not solve dynamic path.');\n\n    spec = helpers.pathObject(path, {$set: val});\n  }\n  else {\n    spec[key] = {$set: val};\n  }\n\n  return this.update(spec);\n};\n\nCursor.prototype.edit = function(val) {\n  return this.update({$set: val});\n};\n\nCursor.prototype.unset = function(key) {\n  if (!key && key !== 0)\n    throw Error('baobab.Cursor.unset: expects a valid key to unset.');\n\n  if (typeof this.reference() !== 'object')\n    throw Error('baobab.Cursor.set: trying to set key to a non-object.');\n\n  var spec = {};\n  spec[key] = {$unset: true};\n  return this.update(spec);\n};\n\nCursor.prototype.remove = function() {\n  if (this.isRoot())\n    throw Error('baobab.Cursor.remove: cannot remove root node.');\n\n  return this.update({$unset: true});\n};\n\nCursor.prototype.apply = function(fn) {\n  if (typeof fn !== 'function')\n    throw Error('baobab.Cursor.apply: argument is not a function.');\n\n  return this.update({$apply: fn});\n};\n\nCursor.prototype.chain = function(fn) {\n  if (typeof fn !== 'function')\n    throw Error('baobab.Cursor.chain: argument is not a function.');\n\n  return this.update({$chain: fn});\n};\n\nCursor.prototype.push = function(value) {\n  if (!(this.reference() instanceof Array))\n    throw Error('baobab.Cursor.push: trying to push to non-array value.');\n\n  if (arguments.length > 1)\n    return this.update({$push: helpers.arrayOf(arguments)});\n  else\n    return this.update({$push: value});\n};\n\nCursor.prototype.unshift = function(value) {\n  if (!(this.reference() instanceof Array))\n    throw Error('baobab.Cursor.push: trying to push to non-array value.');\n\n  if (arguments.length > 1)\n    return this.update({$unshift: helpers.arrayOf(arguments)});\n  else\n    return this.update({$unshift: value});\n};\n\nCursor.prototype.merge = function(o) {\n  if (!type.Object(o))\n    throw Error('baobab.Cursor.merge: trying to merge a non-object.');\n\n  if (!type.Object(this.reference()))\n    throw Error('baobab.Cursor.merge: trying to merge into a non-object.');\n\n  this.update({$merge: o});\n};\n\nCursor.prototype.update = function(spec) {\n  this.tree.update(helpers.pathObject(this.solvedPath, spec));\n  return this;\n};\n\n/**\n * Combination\n */\nCursor.prototype.or = function(otherCursor) {\n  return new Combination('or', this, otherCursor);\n};\n\nCursor.prototype.and = function(otherCursor) {\n  return new Combination('and', this, otherCursor);\n};\n\n/**\n * Releasing\n */\nCursor.prototype.release = function() {\n\n  // Removing listener on parent\n  this.tree.off('update', this.updateHandler);\n\n  // If the cursor is hashed, we unsubscribe from the parent\n  if (this.hash)\n    delete this.tree._cursors[this.hash];\n\n  // Dereferencing\n  delete this.tree;\n  delete this.path;\n  delete this.solvePath;\n\n  // Killing emitter\n  this.kill();\n};\n\n/**\n * Output\n */\nCursor.prototype.toJSON = function() {\n  return this.reference();\n};\n\ntype.Cursor = function (value) {\n  return value instanceof Cursor;\n};\n\n/**\n * Export\n */\nmodule.exports = Cursor;\n\n},{\"./combination.js\":13,\"./helpers.js\":15,\"./mixins.js\":17,\"./type.js\":18,\"emmett\":10}],15:[function(require,module,exports){\n/**\n * Baobab Helpers\n * ===============\n *\n * Miscellaneous helper functions.\n */\nvar type = require('./type.js');\n\n// Make a real array of an array-like object\nfunction arrayOf(o) {\n  return Array.prototype.slice.call(o);\n}\n\n// Shallow merge\nfunction shallowMerge(o1, o2) {\n  var o = {},\n      k;\n\n  for (k in o1) o[k] = o1[k];\n  for (k in o2) o[k] = o2[k];\n\n  return o;\n}\n\n// Clone a regexp\nfunction cloneRegexp(re) {\n  var pattern = re.source,\n      flags = '';\n\n  if (re.global) flags += 'g';\n  if (re.multiline) flags += 'm';\n  if (re.ignoreCase) flags += 'i';\n  if (re.sticky) flags += 'y';\n  if (re.unicode) flags += 'u';\n\n  return new RegExp(pattern, flags);\n}\n\n// Cloning function\nfunction clone(deep, item) {\n  if (!item ||\n      typeof item !== 'object' ||\n      item instanceof Error ||\n      item instanceof ArrayBuffer)\n    return item;\n\n  // Array\n  if (type.Array(item)) {\n    if (deep) {\n      var i, l, a = [];\n      for (i = 0, l = item.length; i < l; i++)\n        a.push(deepClone(item[i]));\n      return a;\n    }\n    else {\n      return item.slice(0);\n    }\n  }\n\n  // Date\n  if (type.Date(item))\n    return new Date(item.getTime());\n\n  // RegExp\n  if (item instanceof RegExp)\n    return cloneRegexp(item);\n\n  // Object\n  if (type.Object(item)) {\n    var k, o = {};\n\n    if (item.constructor && item.constructor !== Object)\n      o = Object.create(item.constructor.prototype);\n\n    for (k in item)\n      if (item.hasOwnProperty(k))\n        o[k] = deep ? deepClone(item[k]) : item[k];\n    return o;\n  }\n\n  return item;\n}\n\n// Shallow & deep cloning functions\nvar shallowClone = clone.bind(null, false),\n    deepClone = clone.bind(null, true);\n\n// Simplistic composition\nfunction compose(fn1, fn2) {\n  return function(arg) {\n    return fn2(fn1(arg));\n  };\n}\n\n// Get first item matching predicate in list\nfunction first(a, fn) {\n  var i, l;\n  for (i = 0, l = a.length; i < l; i++) {\n    if (fn(a[i]))\n      return a[i];\n  }\n  return;\n}\n\nfunction index(a, fn) {\n  var i, l;\n  for (i = 0, l = a.length; i < l; i++) {\n    if (fn(a[i]))\n      return i;\n  }\n  return -1;\n}\n\n// Compare object to spec\nfunction compare(object, spec) {\n  var ok = true,\n      k;\n\n  // If we reached here via a recursive call, object may be undefined because\n  // not all items in a collection will have the same deep nesting structure\n  if (!object) {\n    return false;\n  }\n\n  for (k in spec) {\n    if (type.Object(spec[k])) {\n      ok = ok && compare(object[k], spec[k]);\n    }\n    else if (type.Array(spec[k])) {\n      ok = ok && !!~spec[k].indexOf(object[k]);\n    }\n    else {\n      if (object[k] !== spec[k])\n        return false;\n    }\n  }\n\n  return ok;\n}\n\nfunction firstByComparison(object, spec) {\n  return first(object, function(e) {\n    return compare(e, spec);\n  });\n}\n\nfunction indexByComparison(object, spec) {\n  return index(object, function(e) {\n    return compare(e, spec);\n  });\n}\n\n// Retrieve nested objects\nfunction getIn(object, path) {\n  path = path || [];\n\n  var c = object,\n      i,\n      l;\n\n  for (i = 0, l = path.length; i < l; i++) {\n    if (!c)\n      return;\n\n    if (typeof path[i] === 'function') {\n      if (!type.Array(c))\n        return;\n\n      c = first(c, path[i]);\n    }\n    else if (typeof path[i] === 'object') {\n      if (!type.Array(c))\n        return;\n\n      c = firstByComparison(c, path[i]);\n    }\n    else {\n      c = c[path[i]];\n    }\n  }\n\n  return c;\n}\n\n// Solve a complex path\nfunction solvePath(object, path) {\n  var solvedPath = [],\n      c = object,\n      idx,\n      i,\n      l;\n\n  for (i = 0, l = path.length; i < l; i++) {\n    if (!c)\n      return null;\n\n    if (typeof path[i] === 'function') {\n      if (!type.Array(c))\n        return;\n\n      idx = index(c, path[i]);\n      solvedPath.push(idx);\n      c = c[idx];\n    }\n    else if (typeof path[i] === 'object') {\n      if (!type.Array(c))\n        return;\n\n      idx = indexByComparison(c, path[i]);\n      solvedPath.push(idx);\n      c = c[idx];\n    }\n    else {\n      solvedPath.push(path[i]);\n      c = c[path[i]] || {};\n    }\n  }\n\n  return solvedPath;\n}\n\n// Return a fake object relative to the given path\nfunction pathObject(path, spec) {\n  var l = path.length,\n      o = {},\n      c = o,\n      i;\n\n  if (!l)\n    o = spec;\n\n  for (i = 0; i < l; i++) {\n    c[path[i]] = (i + 1 === l) ? spec : {};\n    c = c[path[i]];\n  }\n\n  return o;\n}\n\nfunction inherits(ctor, superCtor) {\n  ctor.super_ = superCtor;\n  var TempCtor = function () {};\n  TempCtor.prototype = superCtor.prototype;\n  ctor.prototype = new TempCtor();\n  ctor.prototype.constructor = ctor;\n}\n\nmodule.exports = {\n  arrayOf: arrayOf,\n  deepClone: deepClone,\n  shallowClone: shallowClone,\n  shallowMerge: shallowMerge,\n  compose: compose,\n  getIn: getIn,\n  inherits: inherits,\n  pathObject: pathObject,\n  solvePath: solvePath\n};\n\n},{\"./type.js\":18}],16:[function(require,module,exports){\n/**\n * Baobab Merge\n * =============\n *\n * A function used to merge updates in the stack.\n */\nvar helpers = require('./helpers.js'),\n    type = require('./type.js');\n\n// Helpers\nfunction hasKey(o, key) {\n  return key in (o || {});\n}\n\nfunction conflict(a, b, key) {\n  return hasKey(a, key) && hasKey(b, key);\n}\n\n// Main function\nfunction merge() {\n  var res = {},\n      current,\n      next,\n      l = arguments.length,\n      i,\n      k;\n\n  for (i = l - 1; i >= 0; i--) {\n\n    // Upper $set/$apply... and conflicts\n    // When solving conflicts, here is the priority to apply:\n    // -- 0) $unset\n    // -- 1) $set\n    // -- 2) $merge\n    // -- 3) $apply\n    // -- 4) $chain\n    if (arguments[i].$unset) {\n      delete res.$set;\n      delete res.$apply;\n      delete res.$merge;\n      res.$unset = arguments[i].$unset;\n    }\n    else if (arguments[i].$set) {\n      delete res.$apply;\n      delete res.$merge;\n      delete res.$unset;\n      res.$set = arguments[i].$set;\n      continue;\n    }\n    else if (arguments[i].$merge) {\n      delete res.$set;\n      delete res.$apply;\n      delete res.$unset;\n      res.$merge = arguments[i].$merge;\n      continue;\n    }\n    else if (arguments[i].$apply){\n      delete res.$set;\n      delete res.$merge;\n      delete res.$unset;\n      res.$apply = arguments[i].$apply;\n      continue;\n    }\n    else if (arguments[i].$chain) {\n      delete res.$set;\n      delete res.$merge;\n      delete res.$unset;\n\n      if (res.$apply)\n        res.$apply = helpers.compose(res.$apply, arguments[i].$chain);\n      else\n        res.$apply = arguments[i].$chain;\n      continue;\n    }\n\n    for (k in arguments[i]) {\n      current = res[k];\n      next = arguments[i][k];\n\n      if (current && type.Object(next)) {\n\n        // $push conflict\n        if (conflict(current, next, '$push')) {\n          if (type.Array(current.$push))\n            current.$push = current.$push.concat(next.$push);\n          else\n            current.$push = [current.$push].concat(next.$push);\n        }\n\n        // $unshift conflict\n        else if (conflict(current, next, '$unshift')) {\n          if (type.Array(next.$unshift))\n            current.$unshift = next.$unshift.concat(current.$unshift);\n          else\n            current.$unshift = [next.$unshift].concat(current.$unshift);\n        }\n\n        // No conflict\n        else {\n          res[k] = merge(next, current);\n        }\n      }\n      else {\n        res[k] = next;\n      }\n    }\n  }\n\n  return res;\n}\n\nmodule.exports = merge;\n\n},{\"./helpers.js\":15,\"./type.js\":18}],17:[function(require,module,exports){\n/**\n * Baobab React Mixins\n * ====================\n *\n * Compilation of react mixins designed to deal with cursors integration.\n */\nvar Combination = require('./combination.js'),\n    type = require('./type.js');\n\nmodule.exports = {\n  baobab: function(baobab) {\n    return {\n\n      // Run Baobab mixin first to allow mixins to access cursors\n      mixins: [{\n        getInitialState: function() {\n\n          // Binding baobab to instance\n          this.tree = baobab;\n\n          // Is there any cursors to create?\n          if (!this.cursor && !this.cursors)\n            return {};\n\n          // Is there conflicting definitions?\n          if (this.cursor && this.cursors)\n            throw Error('baobab.mixin: you cannot have both ' +\n                        '`component.cursor` and `component.cursors`. Please ' +\n                        'make up your mind.');\n\n          // Type\n          this.__type = null;\n\n          // Making update handler\n          this.__updateHandler = (function() {\n            this.setState(this.__getCursorData());\n          }).bind(this);\n\n          if (this.cursor) {\n            if (!type.MixinCursor(this.cursor))\n              throw Error('baobab.mixin.cursor: invalid data (cursor, ' +\n                          'string, array or function).');\n\n            if (type.Function(this.cursor))\n              this.cursor = this.cursor();\n\n            if (!type.Cursor(this.cursor))\n              this.cursor = baobab.select(this.cursor);\n\n            this.__getCursorData = (function() {\n              return {cursor: this.cursor.get()};\n            }).bind(this);\n            this.__type = 'single';\n          }\n          else if (this.cursors) {\n            if (!type.MixinCursors(this.cursors))\n              throw Error('baobab.mixin.cursor: invalid data (object, array or function).');\n\n            if (type.Function(this.cursors))\n              this.cursors = this.cursors();\n\n            if (type.Array(this.cursors)) {\n              this.cursors = this.cursors.map(function(path) {\n                return type.Cursor(path) ? path : baobab.select(path);\n              });\n\n              this.__getCursorData = (function() {\n                return {cursors: this.cursors.map(function(cursor) {\n                  return cursor.get();\n                })};\n              }).bind(this);\n              this.__type = 'array';\n            }\n            else {\n              for (var k in this.cursors) {\n                if (!type.Cursor(this.cursors[k]))\n                  this.cursors[k] = baobab.select(this.cursors[k]);\n              }\n\n              this.__getCursorData = (function() {\n                var d = {};\n                for (k in this.cursors)\n                  d[k] = this.cursors[k].get();\n                return {cursors: d};\n              }).bind(this);\n              this.__type = 'object';\n            }\n          }\n\n          return this.__getCursorData();\n        },\n        componentDidMount: function() {\n          if (this.__type === 'single') {\n            this.__combination = new Combination('or', [this.cursor]);\n            this.__combination.on('update', this.__updateHandler);\n          }\n          else if (this.__type === 'array') {\n            this.__combination = new Combination('or', this.cursors);\n            this.__combination.on('update', this.__updateHandler);\n          }\n          else if (this.__type === 'object') {\n            this.__combination = new Combination(\n              'or',\n              Object.keys(this.cursors).map(function(k) {\n                return this.cursors[k];\n              }, this)\n            );\n            this.__combination.on('update', this.__updateHandler);\n          }\n        },\n        componentWillUnmount: function() {\n          if (this.__combination)\n            this.__combination.release();\n        }\n      }].concat(baobab.options.mixins)\n    };\n  },\n  cursor: function(cursor) {\n    return {\n\n      // Run cursor mixin first to allow mixins to access cursors\n      mixins: [{\n        getInitialState: function() {\n\n          // Binding cursor to instance\n          this.cursor = cursor;\n\n          // Making update handler\n          this.__updateHandler = (function() {\n            this.setState({cursor: this.cursor.get()});\n          }).bind(this);\n\n          return {cursor: this.cursor.get()};\n        },\n        componentDidMount: function() {\n\n          // Listening to updates\n          this.cursor.on('update', this.__updateHandler);\n        },\n        componentWillUnmount: function() {\n\n          // Unbinding handler\n          this.cursor.off('update', this.__updateHandler);\n        }\n      }].concat(cursor.tree.options.mixins)\n    };\n  }\n};\n\n},{\"./combination.js\":13,\"./type.js\":18}],18:[function(require,module,exports){\n/**\n * Baobab Type Checking\n * =====================\n *\n * Misc helpers functions used throughout the library to perform some type\n * tests at runtime.\n *\n * @christianalfoni\n */\n\n// Not reusing methods as it will just be an extra\n// call on the stack\nvar type = function (value) {\n  if (Array.isArray(value)) {\n    return 'array';\n  } else if (typeof value === 'object' && value !== null) {\n    return 'object';\n  } else if (typeof value === 'string') {\n    return 'string';\n  } else if (typeof value === 'number') {\n    return 'number';\n  } else if (typeof value === 'boolean') {\n    return 'boolean';\n  } else if (typeof value === 'function') {\n    return 'function';\n  } else if (value === null) {\n    return 'null';\n  } else if (value === undefined) {\n    return 'undefined';\n  } else if (value instanceof Date) {\n    return 'date';\n  } else {\n    return 'invalid';\n  }\n};\n\ntype.Array = function (value) {\n  return Array.isArray(value);\n};\n\ntype.Object = function (value) {\n  return !Array.isArray(value) && typeof value === 'object' && value !== null;\n};\n\ntype.String = function (value) {\n  return typeof value === 'string';\n};\n\ntype.Number = function (value) {\n  return typeof value === 'number';\n};\n\ntype.Boolean = function (value) {\n  return typeof value === 'boolean';\n};\n\ntype.Function = function (value) {\n  return typeof value === 'function';\n};\n\ntype.Primitive = function (value) {\n  return typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean';\n};\n\ntype.Date = function (value) {\n  return value instanceof Date;\n};\n\ntype.Step = function (value) {\n  var valueType = type(value);\n  var notValid = ['null', 'undefined', 'invalid', 'date'];\n  return notValid.indexOf(valueType) === -1;\n};\n\n// Should undefined be allowed?\ntype.Path = function (value) {\n  var types = ['object', 'string', 'number', 'function', 'undefined'];\n  if (type.Array(value)) {\n    for (var x = 0; x < value.length; x++) {\n      if (types.indexOf(type(value[x])) === -1) {\n        return false;\n      }\n    }\n  } else {\n    return types.indexOf(type(value)) >= 0;\n  }\n  return true;\n\n};\n\n// string|number|array|cursor|function\ntype.MixinCursor = function (value) {\n  var allowedValues = ['string', 'number', 'array', 'function'];\n  return allowedValues.indexOf(type(value)) >= 0 || type.Cursor(value);\n};\n\n// array|object|function\ntype.MixinCursors = function (value) {\n  var allowedValues = ['array', 'object', 'function'];\n  return allowedValues.indexOf(type(value)) >= 0;\n};\n\n// Already know this is an array\ntype.ComplexPath = function (value) {\n  var complexTypes = ['object', 'function'];\n  for (var x = 0; x < value.length; x++) {\n    if (complexTypes.indexOf(type(value[x])) >= 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\nmodule.exports = type;\n\n},{}],19:[function(require,module,exports){\n/**\n * Baobab Update\n * ==============\n *\n * A handy method to mutate an atom according to the given specification.\n * Mostly inspired by http://facebook.github.io/react/docs/update.html\n */\nvar helpers = require('./helpers.js'),\n    type = require('./type.js');\n\nvar COMMANDS = {};\n[\n  '$set',\n  '$push',\n  '$unshift',\n  '$apply',\n  '$merge'\n].forEach(function(c) {\n  COMMANDS[c] = true;\n});\n\n// Helpers\nfunction makeError(path, message) {\n  var e = new Error('baobab.update: ' + message + ' at path /' +\n                    path.toString());\n\n  e.path = path;\n  return e;\n}\n\n// Core function\nfunction update(target, spec, opts) {\n  opts = opts || {shiftReferences: false};\n  var log = {};\n\n  // Closure mutating the internal object\n  (function mutator(o, spec, path, parent) {\n    path = path || [];\n\n    var hash = path.join('λ'),\n        fn,\n        h,\n        k,\n        v;\n\n    for (k in spec) {\n      if (COMMANDS[k]) {\n        v = spec[k];\n\n        // Logging update\n        log[hash] = true;\n\n        // TODO: this could be before in the recursion\n        // Applying\n        switch (k) {\n          case '$push':\n            if (!type.Array(o))\n              throw makeError(path, 'using command $push to a non array');\n\n            if (!type.Array(v))\n              o.push(v);\n            else\n              o.push.apply(o, v);\n            break;\n          case '$unshift':\n            if (!type.Array(o))\n              throw makeError(path, 'using command $unshift to a non array');\n\n            if (!type.Array(v))\n              o.unshift(v);\n            else\n              o.unshift.apply(o, v);\n            break;\n        }\n      }\n      else {\n        h = hash ? hash + 'λ' + k : k;\n\n        if ('$unset' in (spec[k] || {})) {\n\n          // Logging update\n          log[h] = true;\n\n          if (type.Array(o)) {\n            if (!opts.shiftReferences)\n              o.splice(k, 1);\n            else\n              parent[path[path.length - 1]] = o.slice(0, +k).concat(o.slice(+k + 1));\n          }\n          else {\n            delete o[k];\n          }\n        }\n        else if ('$set' in (spec[k] || {})) {\n          v = spec[k].$set;\n\n          // Logging update\n          log[h] = true;\n          o[k] = v;\n        }\n        else if ('$apply' in (spec[k] || {}) || '$chain' in (spec[k] || {})) {\n\n          // TODO: this should not happen likewise.\n          fn = spec[k].$apply || spec[k].$chain;\n\n          if (typeof fn !== 'function')\n            throw makeError(path.concat(k), 'using command $apply with a non function');\n\n          // Logging update\n          log[h] = true;\n          o[k] = fn.call(null, o[k]);\n        }\n        else if ('$merge' in (spec[k] || {})) {\n          v = spec[k].$merge;\n\n          if (!type.Object(o[k]))\n            throw makeError(path.concat(k), 'using command $merge on a non-object');\n\n          // Logging update\n          log[h] = true;\n          o[k] = helpers.shallowMerge(o[k], v);\n        }\n        else if (opts.shiftReferences &&\n                 ('$push' in (spec[k] || {}) ||\n                  '$unshift' in (spec[k] || {}))) {\n          if ('$push' in (spec[k] || {})) {\n            v = spec[k].$push;\n\n            if (!type.Array(o[k]))\n              throw makeError(path.concat(k), 'using command $push to a non array');\n            o[k] = o[k].concat(v);\n          }\n          if ('$unshift' in (spec[k] || {})) {\n            v = spec[k].$unshift;\n\n            if (!type.Array(o[k]))\n              throw makeError(path.concat(k), 'using command $unshift to a non array');\n            o[k] = (v instanceof Array ? v : [v]).concat(o[k]);\n          }\n\n          // Logging update\n          log[h] = true;\n        }\n        else {\n\n          // If nested object does not exist, we create it\n          if (typeof o[k] === 'undefined')\n            o[k] = {};\n\n          // Shifting reference\n          if (opts.shiftReferences)\n            o[k] = helpers.shallowClone(o[k]);\n\n          // Recur\n          // TODO: fix this horrendous behaviour.\n          mutator(\n            o[k],\n            spec[k],\n            path.concat(k),\n            o\n          );\n        }\n      }\n    }\n  })(target, spec);\n\n  return Object.keys(log).map(function(hash) {\n    return hash.split('λ');\n  });\n}\n\n// Exporting\nmodule.exports = update;\n\n},{\"./helpers.js\":15,\"./type.js\":18}],20:[function(require,module,exports){\nfunction classNames() {\n\tvar classes = '';\n\tvar arg;\n\n\tfor (var i = 0; i < arguments.length; i++) {\n\t\targ = arguments[i];\n\t\tif (!arg) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ('string' === typeof arg || 'number' === typeof arg) {\n\t\t\tclasses += ' ' + arg;\n\t\t} else if (Object.prototype.toString.call(arg) === '[object Array]') {\n\t\t\tclasses += ' ' + classNames.apply(null, arg);\n\t\t} else if ('object' === typeof arg) {\n\t\t\tfor (var key in arg) {\n\t\t\t\tif (!arg.hasOwnProperty(key) || !arg[key]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tclasses += ' ' + key;\n\t\t\t}\n\t\t}\n\t}\n\treturn classes.substr(1);\n}\n\n// safely export classNames in case the script is included directly on a page\nif (typeof module !== 'undefined' && module.exports) {\n\tmodule.exports = classNames;\n}\n\n},{}]},{},[1]);\n"],"file":"search.js","sourceRoot":"/source/"}